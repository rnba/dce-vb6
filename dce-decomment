#!/usr/bin/sed -Ef

b main

:error
s/^/ERROR: /
w /dev/stderr
q 1

:main

# the "Rem" comment leader is dealt with
# swiftly here: grep suggests it's only
# used as the first token on a line
# or inside a '-comment.

# lines where either comment leader is
# the first non-WS character are dropped
# completely, no need to leave behind
# /^\s+$/-matching junk...

# but lines that were such a junk before
# stay as is.  there's a shitton of that
# in the code this is written for,
# so let's keep the diff focussed.

# now for the interesting bit.

# the trouble with finding comments without
# an actual lexer is in string literals:
#
#  r = 42 ' this is trivial
#  s = "not a 'comment'!" ' this isn't

# we know that this line contains both
# quotes (") and apostrophes ('),
# and that the first quote comes before
# the first apostrophe.
# 
#  "You're", "They're" ', "Your", "Their"
#
# pattern space is one line with the
# linefeed removed, so let's use that
# as a marker, moving it just past
# the next string literal on each pass.

/^\s*('|Rem\>)/ d

/^\s*$/ b asis

/('|\<Rem\>)/! b asis

/^([^'"]*)('|\<Rem\>).*/ {
  s//\1/
  b strip
}

s/^/\n/
:string
/^(.*)\n([^'"]*"[^"]*")(.*)$/ {
  s//\1\2\n\3/
  b string
}

# the \n is past all string literals.
/^(.*)\n([^']*)('.*)?/ {
  s//\1\2/
  b strip
}

# insurance policy against bugs
:unhandled
b error

:strip
s/\s+$//

:asis
