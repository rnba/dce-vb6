#!/usr/bin/sed -Enf

# the "Rem" comment leader is dealt with
# swiftly here: grep suggests that it's only
# used as the first token on a line
# or inside a '-comment

# lines where the comment leader is the
# first non-WS character are dropped
# completely, no need to leave behind
# /^\s+$/-matching junk

/^\s*('|Rem\>)/ b

# but lines that were such a junk before
# stay as is.  there's a shitton of that
# out there, let's keep the diff focussed.

/^\s*$/ b asis

/('|\<Rem\>)/! b strip

# the trouble with finding comments without
# an actual lexer is in string literals:
#
#  s = "not a 'comment'!" ' let's party!
#
# first get the easy ones off the table:

/^([^'"]*)('|\<Rem\>).*/ {
  s//\1/
  b strip
}

# now for the interesting bit.
# we know that this line contains both
# quotes (") and apostrophes ('),
# and that the first quote comes before
# the first apostrophe.
# 
#  "You're", "They're" ', "Your", "Their"
#
# pattern space is one line with the
# linefeed removed, so let's use that
# as a marker, moving it just past
# the next string literal on each pass.

s/^/\n/
:strings
/^(.*)\n([^'"]*"[^"]*")(.*)$/ {
  s//\1\2\n\3/
  b strings
}

# the \n is past all string literals
/^(.*)\n([^']*)('.*)?/ {
  s//\1\2/
  b strip
}

:error
s/^/ERROR: /
w /dev/stderr
q 1

:strip
s/\s+$//

:asis
p
